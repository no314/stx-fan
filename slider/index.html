<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leather Jelly Slider</title>
    <style>
        body { margin: 0; overflow: hidden; background: #f0f0f0; }
        #percentage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; font-family: Arial, sans-serif; color: #333; pointer-events: none; }
    </style>
</head>
<body>
    <div id="percentage">50%</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js?module",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f8ff);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 10;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Texture
        const textureLoader = new THREE.TextureLoader();
        const leatherTexture = textureLoader.load('https://dl.polyhaven.org/file/ph-assets/Textures/jpg/1k/brown_leather/brown_leather_diff_1k.jpg');
        leatherTexture.wrapS = leatherTexture.wrapT = THREE.RepeatWrapping;
        leatherTexture.repeat.set(2, 1);

        // Jelly slider geometry - subdivided plane for deformation
        const geometry = new THREE.PlaneGeometry(4, 0.3, 64, 16); // Wide, thin, highly subdivided for wobble
        geometry.attributes.position.needsUpdate = true;

        // Custom shader for jelly wobble
        const uniforms = {
            time: { value: 0 },
            mouse: { value: new THREE.Vector2(0.5, 0.5) },
            amplitude: { value: 0.0 }
        };

        const vertexShader = `
            uniform float time;
            uniform vec2 mouse;
            uniform float amplitude;
            varying vec2 vUv;
            varying vec3 vPosition;

            void main() {
                vUv = uv;
                vec3 pos = position;

                // Jelly wobble: sine wave displacement based on x and time
                float wave = sin(pos.x * 10.0 + time * 5.0) * 0.02 * amplitude;
                pos.z += wave * (1.0 - abs(pos.x)); // Curve towards center

                // Mouse interaction: pull towards mouse
                float dist = distance(uv, mouse);
                pos.z += (1.0 - dist) * 0.1 * amplitude;

                vPosition = pos;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D map;
            varying vec2 vUv;
            varying vec3 vPosition;

            void main() {
                vec4 texColor = texture2D(map, vUv);
                gl_FragColor = texColor;
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            side: THREE.DoubleSide
        });

        material.uniforms.map = { value: leatherTexture };

        const slider = new THREE.Mesh(geometry, material);
        slider.rotation.x = -Math.PI / 2;
        slider.position.y = -0.5;
        scene.add(slider);

        // Add a track for the slider (simple box)
        const trackGeometry = new THREE.BoxGeometry(5, 0.01, 0.1);
        const trackMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const track = new THREE.Mesh(trackGeometry, trackMaterial);
        track.position.y = -0.6;
        scene.add(track);

        // Camera position
        camera.position.set(0, 0, 3);

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let dragStartX = 0;
        let sliderStartX = 0;

        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(slider);
            if (intersects.length > 0) {
                isDragging = true;
                dragStartX = event.clientX;
                sliderStartX = slider.position.x;
                uniforms.amplitude.value = 1.0; // Start wobble
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = (event.clientX - dragStartX) / window.innerWidth * 4; // Scale to slider width
                slider.position.x = Math.max(-2, Math.min(2, sliderStartX + deltaX));
                uniforms.mouse.value.x = (slider.position.x + 2) / 4; // Normalize to 0-1

                // Update percentage
                const percent = Math.round(((slider.position.x + 2) / 4) * 100);
                document.getElementById('percentage').textContent = percent + '%';
            }
        }

        function onMouseUp() {
            if (isDragging) {
                isDragging = false;
                // Dampen amplitude over time
                const dampen = () => {
                    uniforms.amplitude.value *= 0.95;
                    if (uniforms.amplitude.value > 0.01) requestAnimationFrame(dampen);
                };
                dampen();
            }
        }

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            uniforms.time.value += 0.01;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>